---
description: 
globs: 
alwaysApply: true
---
---
description: BFF development guidelines
globs: ["./api/*", "./services/*", "./common/*", "*/middlewares/*", ]
alwaysApply: true
---

# BFF Development Guidelines

## Instru√ß√µes para LLM

**A√á√ÉO OBRIGAT√ìRIA**: Quando solicitado para desenvolver c√≥digo BFF, siga EXATAMENTE esta sequ√™ncia:

1. **ANALISAR**: Execute an√°lise t√©cnica completa antes de qualquer implementa√ß√£o
2. **ESTRUTURAR**: Organize o desenvolvimento seguindo os padr√µes estabelecidos
3. **IMPLEMENTAR**: Use os patterns e melhores pr√°ticas definidas
4. **VERIFICAR**: Execute `npx eslint [arquivo]` no arquivo espec√≠fico
5. **VALIDAR**: Confirme que seguiu todas as diretrizes antes de finalizar

**IMPORTANTE**: Execute lint apenas no arquivo espec√≠fico para economia de recursos.

## Fluxo de Desenvolvimento Linear

```
IN√çCIO
  ‚Üì
üìã Consultar [Matriz de Prioridades](mdc:#0-matriz-de-prioridades)
  ‚Üì
üîç Executar [An√°lise T√©cnica](mdc:#1-an√°lise-t√©cnica)
  ‚Üì
üõ†Ô∏è Aplicar [API Patterns](mdc:#3-api-patterns) + [Service Layer](mdc:#4-service-layer)
  ‚Üì
‚öñÔ∏è Conflito? ‚Üí [Resolu√ß√£o de Conflitos](mdc:#resolu√ß√£o-de-conflitos)
  ‚Üì
‚úÖ [Verifica√ß√£o e Valida√ß√£o](mdc:#9-verifica√ß√£o-e-valida√ß√£o)
  ‚Üì
üéØ FINALIZADO
```

## Modo R√°pido (Para mudan√ßas simples)

**Use quando**: Pequenas corre√ß√µes, ajustes de configura√ß√£o, ou mudan√ßas triviais

**Processo simplificado**:
1. ‚úÖ Verificar se √© realmente simples (sem l√≥gica complexa)
2. üõ†Ô∏è Implementar seguindo padr√µes b√°sicos
3. üîç Executar `npx eslint [arquivo]`
4. ‚úÖ Validar apenas itens "Cr√≠ticos" do checklist

**Pular para casos simples**: An√°lise detalhada, documenta√ß√£o extensa, valida√ß√£o completa

## Quando Aplicar

Esta rule deve ser aplicada quando:
- Desenvolver handlers de API
- Implementar middleware de autentica√ß√£o/autoriza√ß√£o
- Criar servi√ßos de integra√ß√£o com APIs externas
- Implementar tratamento de erros customizado
- Configurar logging e monitoramento
- Desenvolver valida√ß√µes de entrada/sa√≠da
- Implementar upload de arquivos

## √çndice de Navega√ß√£o R√°pida

- üö® [Matriz de Prioridades](mdc:#0-matriz-de-prioridades) - **Consulte PRIMEIRO**
- ‚öñÔ∏è [Resolu√ß√£o de Conflitos](mdc:#resolu√ß√£o-de-conflitos) - Para decis√µes dif√≠ceis
- üîç [An√°lise T√©cnica](mdc:#1-an√°lise-t√©cnica) - In√≠cio do desenvolvimento
- üõ†Ô∏è [API Patterns](mdc:#3-api-patterns) - Durante implementa√ß√£o
- ‚úÖ [Checklist Final](mdc:#9-verifica√ß√£o-e-valida√ß√£o) - Antes de finalizar

## 0. Matriz de Prioridades

### Cr√≠tico (Bloqueia desenvolvimento)
- Lint sem erros
- Tipos TypeScript corretos
- Tratamento de erro implementado
- Autentica√ß√£o/autoriza√ß√£o funcionais

### Importante (Impacta qualidade)
- Logging apropriado
- Valida√ß√£o de entrada/sa√≠da
- Estrutura de handlers
- Padr√µes de nomenclatura

### Opcional (Melhoria incremental)
- Otimiza√ß√µes de performance
- Documenta√ß√£o adicional
- Monitoramento avan√ßado

## Resolu√ß√£o de Conflitos

### Ordem de Preced√™ncia:
1. **Seguran√ßa > Performance**: Nunca comprometa seguran√ßa por performance
2. **Funcionalidade > Padr√µes**: Se um padr√£o impede a funcionalidade, priorize a funcionalidade
3. **Legibilidade > Otimiza√ß√£o**: C√≥digo leg√≠vel √© mais importante que micro-otimiza√ß√µes
4. **Conven√ß√µes do projeto > Prefer√™ncias pessoais**: Siga o que j√° existe no projeto

### Protocolo de Decis√£o:
1. **Identifique o conflito**: Qual diretriz est√° sendo violada?
2. **Consulte a preced√™ncia**: Use a ordem acima para decidir
3. **Documente a exce√ß√£o**: Explique por que divergiu
4. **Valide o m√≠nimo**: Garanta que itens "Cr√≠ticos" ainda s√£o atendidos

### Exemplos Pr√°ticos:
```typescript
// ‚ùå Conflito: Performance vs Seguran√ßa
// Performance diz: cache dados sens√≠veis
// Mas: dados cont√™m informa√ß√µes pessoais

// ‚úÖ Resolu√ß√£o: Priorizar seguran√ßa
// N√£o fazer cache de dados sens√≠veis, implementar cache seletivo
```

### Quando Divergir:
- **Documente**: Adicione coment√°rio explicando a exce√ß√£o
- **Valide cr√≠ticos**: Confirme que seguran√ßa e funcionalidade n√£o s√£o comprometidas
- **Priorize entrega**: Funcionalidade working > padr√£o perfeito

## 1. An√°lise T√©cnica

**ANTES DE INICIAR**: Consulte a [Matriz de Prioridades](mdc:#0-matriz-de-prioridades)

### Processo de An√°lise
**EXECUTAR OBRIGATORIAMENTE antes de qualquer implementa√ß√£o:**

- **Requisitos**: Identificar funcionalidades de API necess√°rias
- **Seguran√ßa**: Mapear necessidades de autentica√ß√£o/autoriza√ß√£o
- **Integra√ß√£o**: Verificar APIs externas e depend√™ncias
- **Performance**: Analisar necessidades de cache e otimiza√ß√£o

**FERRAMENTAS**: Use `codebase_search` e `read_file` para analisar c√≥digo existente.

### Diretrizes de An√°lise
- Identifique requisitos de seguran√ßa e performance
- Use `codebase_search` e `read_file` para contexto
- Documente decis√µes importantes de arquitetura
- Prossiga com implementa√ß√£o quando abordagem estiver clara

## 2. Technology Stack

### Core Technologies
- **Runtime**: Node.js
- **Framework**: Express
- **Language**: TypeScript/JavaScript
- **Security**: Odin Security
- **Logging**: Nordic Logger (LoggerFactory)
- **HTTP Client**: Nordic RestClient
- **Validation**: Zod
- **File Upload**: Multer
- **Testing**: Jest

### Role Definition
Voc√™ √© um engenheiro backend s√™nior especializado em Node.js, Express, TypeScript, seguran√ßa de APIs e frameworks da empresa (Nordic, Odin, Fury).

## 3. API Patterns

### Handler Structure
- Use tipos TypeScript para request/response
- Implemente tratamento de erro consistente
- Inclua logging apropriado com Nordic LoggerFactory
- Use contexto de autentica√ß√£o Odin

```typescript
import type { AuthenticatedUser } from '@/types/odin-security';
import type { Request, Response } from 'express';

import { CustomError } from '../../../common/errors/CustomError';
import { handleErrors } from '../handleErrors';
import { log } from './config';

export async function exampleHandler(req: Request, res: Response) {
  const { context } = req;
  const authenticatedUser = req.auth?.user as AuthenticatedUser;

  const logTags = {
    user_id: authenticatedUser?.userId,
  };

  try {
    log.info('API: Operation description', {
      ...logTags,
      ...context,
    });

    const response = await service({
      authenticatedUser,
      context,
    });

    log.info('API: Successfully completed operation', {
      ...logTags,
      ...context,
    });

    res.json(response);
  } catch (e: unknown) {
    const err = e as Error;

    if (!(e instanceof CustomError)) {
      log.error('API: Operation description', {
        ...logTags,
        error_message: err.message,
        error_stack: err.stack,
        ...context,
      });
    }

    const error = handleErrors(err);
    res.status(error.status).json({ message: error.message });
  }
}
```

### Request/Response Types
- Defina interfaces claras para entrada e sa√≠da
- Use valida√ß√£o Zod em runtime
- Implemente transforma√ß√£o de dados quando necess√°rio

```typescript
import { z } from 'zod';

const CreateUserRequestSchema = z.object({
  name: z.string().min(1, 'Name is required'),
  email: z.string().email('Valid email is required'),
  role: z.enum(['admin', 'user']),
});

type CreateUserRequest = z.infer<typeof CreateUserRequestSchema>;

interface CreateUserResponse {
  id: string;
  name: string;
  email: string;
  createdAt: string;
}

export async function createUserHandler(
  req: Request,
  res: Response<CreateUserResponse>
) {
  // Validate input with Zod
  const validatedData = CreateUserRequestSchema.parse(req.body);
  
  // Implementation
}
```

### Middleware Patterns
- Implemente middleware reutiliz√°vel
- Use Nordic/Odin patterns para auth
- Mantenha middleware focado em uma responsabilidade

```typescript
import { contextMiddleware } from '../middlewares/contextMiddleware';
import { authentication, authorization } from 'odin/security';
import { GLOBAL_ROLES_ALLOWED } from '../common/roles/applicationRoles';

// Context middleware (Nordic pattern)
router.use(contextMiddleware);

// Authentication middleware (Odin pattern)
router.use(authentication());

// Authorization middleware (Odin pattern)
router.use(authorization({
  roles: GLOBAL_ROLES_ALLOWED,
  blockade: unauthorized,
}));
```

### File Upload Patterns
- Use Multer para upload de arquivos
- Configure valida√ß√£o de tipos e tamanhos
- Implemente tratamento de erros espec√≠fico

```typescript
import multer from 'multer';
import { config } from 'nordic/config';
import { ValidationError } from '../../../common/errors';

const attachmentsConfig = config.get('services.attachments');
const { allowedTypes, fileSize } = attachmentsConfig;

const uploadSetup = multer({
  limits: { fileSize },
  fileFilter(req, file, callback) {
    if (!allowedTypes.includes(file.mimetype)) {
      return callback(new ValidationError('Invalid file extension'));
    }

    // Fix UTF-8 filename encoding
    const tempName = file.originalname;
    file.originalname = Buffer.from(tempName, 'latin1').toString('utf8');

    return callback(null, true);
  },
});

const uploadMultiple = uploadSetup.array('files', 100);
```

## 4. Service Layer

### Service Structure
- Separe l√≥gica de neg√≥cio dos handlers
- Use Nordic RestClient para APIs externas
- Implemente tratamento de erro com handleCatch

```typescript
import type { ErrorWithResponse } from '../handleCatch';
import { handleCatch } from '../handleCatch';
import { log, request } from './config';

export const exampleService = async ({
  data,
  authenticatedUser,
  context,
}: ServiceProps) => {
  const logTags = {
    user_id: authenticatedUser?.userId,
  };

  log.info('Service: Operation description', {
    ...logTags,
    ...context,
  });

  try {
    const response = await request.post('/external-api', {
      headers: { 'Content-Type': 'application/json' },
      data,
      context,
    });

    log.info('Service: Successfully completed operation', {
      ...logTags,
      response: JSON.stringify(response.data),
    });

    return response.data;
  } catch (e: unknown) {
    const { error, tags } = handleCatch(e as ErrorWithResponse);

    log.error('Service: Something went wrong', {
      ...logTags,
      ...tags,
      ...context,
    });

    throw error;
  }
};
```

### RestClient Configuration
- Use Nordic RestClient para chamadas externas
- Configure timeouts apropriados
- Implemente retry policies quando necess√°rio

```typescript
import { config } from 'nordic/config';
import { LoggerFactory } from 'nordic/logger';
import { RestClient } from 'nordic/restclient';

const serviceConfig = config.get('services.external');

export const request = RestClient({
  timeout: serviceConfig.timeout,
  baseURL: serviceConfig.baseURL + serviceConfig.path,
});

export const log = LoggerFactory('services.external');
```

## 5. Error Handling

### Custom Error Classes
- Estenda `CustomError` para todos os tipos de erro
- Implemente classes espec√≠ficas para diferentes status HTTP
- Mantenha conven√ß√£o de nomenclatura consistente

```typescript
import { CustomError } from './CustomError';

export class ValidationError extends CustomError {
  name = 'ValidationError';
}

export class UnauthorizedError extends CustomError {
  name = 'UnauthorizedError';
}

export class ServiceUnavailableError extends CustomError {
  name = 'ServiceUnavailableError';
}
```

### Error Handler Function
- Centralize mapeamento de erros para status HTTP
- Use fun√ß√£o handleErrors para consist√™ncia
- Retorne respostas padronizadas

```typescript
import { 
  BadRequest,
  ValidationError,
  UnauthorizedError,
  // ... outros erros
} from '../../common/errors';

const errorsStatus = {
  [ValidationError.name]: 400,
  [UnauthorizedError.name]: 401,
  [ResourceNotFoundError.name]: 404,
  // ... outros mapeamentos
};

export function handleErrors(error: Error): {
  status: number;
  message: string;
} {
  const status = errorsStatus[error.name] || 500;
  return { status, message: error.message };
}
```

### Service Error Handling
- Use handleCatch para erros de APIs externas
- Mapeie status HTTP para classes de erro apropriadas
- Inclua informa√ß√µes de debug em logs

```typescript
export function handleCatch(error: ErrorWithResponse) {
  let instanceError: Error | undefined;
  let status = 500;

  if (error.response) {
    const errorStatus = Number(error.response.status || 500);
    const errorType = statusMap[errorStatus] || unhandledError;
    
    status = error.response.status || 500;
    instanceError = new errorType.ErrorClass(
      error.response.data?.message || errorType.message,
    );
  }

  const tags = {
    status,
    method: error.config?.method,
    url: error.config?.url,
    error: instanceError?.name,
    response: error.response?.data?.message,
    stack: error.stack,
  };

  return {
    error: instanceError || new UnhandledError(error.message),
    tags,
  };
}
```

## 6. Input Validation

### Zod Schema Patterns
- Use Zod para valida√ß√£o de entrada
- Defina schemas reutiliz√°veis
- Implemente mensagens de erro em portugu√™s

```typescript
import { z } from 'zod';

export const CreateAttachmentSchema = z.object({
  files: z.array(z.instanceof(File))
    .min(1, 'Pelo menos um arquivo √© obrigat√≥rio')
    .max(10, 'M√°ximo de 10 arquivos permitidos'),
  metadata: z.object({
    description: z.string().optional(),
    category: z.enum(['document', 'image', 'video']),
  }).optional(),
});

// Validation function
export function validateCreateAttachment(data: unknown) {
  try {
    return CreateAttachmentSchema.parse(data);
  } catch (error) {
    if (error instanceof z.ZodError) {
      throw new ValidationError(error.errors[0].message);
    }
    throw new ValidationError('Invalid input data');
  }
}
```

### Runtime Validation
- Valide dados de entrada em todos os handlers
- Use early returns para falhas de valida√ß√£o
- Sanitize dados quando necess√°rio

```typescript
export async function createHandler(req: Request, res: Response) {
  try {
    // Validate input
    const validatedData = validateCreateAttachment(req.body);
    
    // Process with validated data
    const result = await service(validatedData);
    
    res.json(result);
  } catch (error) {
    // Error handling
  }
}
```

## 7. Security Patterns

### Authentication & Authorization
- Use Odin Security para autentica√ß√£o
- Implemente autoriza√ß√£o baseada em roles
- Valide tokens e permiss√µes

```typescript
import { authentication, authorization } from 'odin/security';
import { GLOBAL_ROLES_ALLOWED } from '../common/roles/applicationRoles';

// Authentication middleware
router.use(authentication());

// Authorization with roles
router.use(authorization({
  roles: GLOBAL_ROLES_ALLOWED,
  blockade: (req: Request, res: Response) => {
    log.error('API: unauthorized access', {
      url: req.url,
      method: req.method,
      user: JSON.stringify(req.auth?.user),
    });
    res.status(403).json({ message: 'unauthorized' });
  },
}));
```

### Data Protection
- Use HTTPS para todas as chamadas
- Implemente rate limiting
- Proteja dados sens√≠veis em logs

```typescript
const secureEndpoint = async (req: Request, res: Response) => {
  // Validate input
  const validatedData = validateInput(req.body);
  
  // Process securely
  const result = await processData(validatedData);
  
  // Sanitize output (remove sensitive data)
  const sanitizedResult = {
    ...result,
    password: undefined,
    token: undefined,
  };
  
  res.json(sanitizedResult);
};
```

## 8. Implementation Guidelines

**LEMBRE-SE**: Consulte [Matriz de Prioridades](mdc:#0-matriz-de-prioridades) para focar no que √© cr√≠tico primeiro.

### Padr√µes Obrigat√≥rios
- Escreva c√≥digo completo e funcional
- N√£o use TODOs ou placeholders
- Inclua todos os imports necess√°rios
- Implemente tratamento de erro robusto
- Use logging estruturado com Nordic LoggerFactory
- Valide entrada e sa√≠da com Zod

```typescript
import type { AuthenticatedUser } from '@/types/odin-security';
import type { Request, Response } from 'express';

import { z } from 'zod';
import { CustomError } from '../../../common/errors/CustomError';
import { ValidationError } from '../../../common/errors';
import { handleErrors } from '../handleErrors';
import { log } from './config';

const RequestSchema = z.object({
  name: z.string().min(1, 'Nome √© obrigat√≥rio'),
  email: z.string().email('Email inv√°lido'),
});

export async function exampleHandler(req: Request, res: Response) {
  const { context } = req;
  const authenticatedUser = req.auth?.user as AuthenticatedUser;

  try {
    // Validate input
    const validatedData = RequestSchema.parse(req.body);
    
    // Process business logic
    const result = await processBusinessLogic(validatedData);
    
    // Log success
    log.info('Operation completed successfully', {
      user_id: authenticatedUser?.userId,
      operation: 'example_operation',
      ...context,
    });
    
    res.json(result);
  } catch (error) {
    if (error instanceof z.ZodError) {
      const validationError = new ValidationError(error.errors[0].message);
      const errorResponse = handleErrors(validationError);
      return res.status(errorResponse.status).json({ message: errorResponse.message });
    }

    const err = error as Error;
    if (!(error instanceof CustomError)) {
      log.error('Unexpected error', {
        user_id: authenticatedUser?.userId,
        error_message: err.message,
        error_stack: err.stack,
        ...context,
      });
    }

    const errorResponse = handleErrors(err);
    res.status(errorResponse.status).json({ message: errorResponse.message });
  }
}
```

### Estrutura√ß√£o do C√≥digo
- Seguir estrutura de pastas do projeto
- Separar handlers, services e middleware
- Organizar imports seguindo padr√µes
- Usar ES6+ syntax para exports

## 9. Verifica√ß√£o e Valida√ß√£o

**EM CASO DE CONFLITO**: Consulte [Resolu√ß√£o de Conflitos](mdc:#resolu√ß√£o-de-conflitos)

### Lint Verification
Execute `npx eslint [arquivo]` no arquivo espec√≠fico antes de finalizar.

**Exemplos:**
```bash
# Para handler de API:
npx eslint api/handlers/attachments/upload-attachments/upload-attachments.ts

# Para middleware:
npx eslint middlewares/contextMiddleware.ts

# Para service:
npx eslint services/attachments/upload-attachment/upload-attachment.ts
```

**Se lint falhar:**
- Corrija TODOS os erros antes de prosseguir
- Use `npx eslint [arquivo] --fix` para corre√ß√µes autom√°ticas

### Checklist de Valida√ß√£o para LLM

**OBRIGAT√ìRIO verificar antes de finalizar:**
**PRIORIZE**: Itens marcados como "Cr√≠tico" na [Matriz de Prioridades](mdc:#0-matriz-de-prioridades)

#### ‚úÖ Cr√≠tico (Bloqueia entrega)
- [ ] Lint executado sem erros no arquivo espec√≠fico
- [ ] Tipos TypeScript corretos
- [ ] Tratamento de erro implementado
- [ ] Autentica√ß√£o/autoriza√ß√£o funcionais

#### ‚úÖ Importante (Impacta qualidade)
- [ ] Logging apropriado com Nordic LoggerFactory
- [ ] Valida√ß√£o de entrada/sa√≠da com Zod
- [ ] Estrutura de handlers seguida
- [ ] Padr√µes de nomenclatura seguidos

**IMPORTANTE**: N√£o finalize sem completar itens "Cr√≠ticos".

## Documentation e Tools

### MCP Servers Dispon√≠veis
- **Fury**: Service discovery, documenta√ß√£o t√©cnica e exemplos de implementa√ß√£o
- **Odin Security**: Padr√µes de seguran√ßa e autentica√ß√£o

### Access Permissions
- Acesso completo ao node_modules para refer√™ncia de documenta√ß√£o, verifica√ß√£o de tipos e exemplos de implementa√ß√£o
