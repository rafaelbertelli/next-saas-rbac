---
description: 
globs: 
alwaysApply: false
---
---
description: Backend testing guidelines
globs: ["apps/api/**/*.spec*"]
alwaysApply: true
---

# Fastify Backend Testing Guidelines

## Instru√ß√µes para LLM

**A√á√ÉO OBRIGAT√ìRIA**: Quando solicitado para criar ou revisar testes de backend, siga EXATAMENTE esta sequ√™ncia:

1. **VERIFICAR**: Confirme se a solicita√ß√£o se enquadra nos crit√©rios da se√ß√£o "Quando Aplicar"
2. **ANALISAR**: Execute an√°lise do c√≥digo backend a ser testado usando ferramentas dispon√≠veis
3. **ESTRUTURAR**: Organize os testes seguindo os padr√µes estabelecidos
4. **IMPLEMENTAR**: Use os patterns e melhores pr√°ticas definidas
5. **EXECUTAR TESTES**: Execute `npm test [arquivo.spec.ts]` para validar que o teste espec√≠fico passa
6. **VALIDAR**: Verifique se seguiu todas as diretrizes antes de finalizar

**ECONOMIA DE RECURSOS**: SEMPRE execute testes apenas nos arquivos espec√≠ficos, n√£o no projeto todo

**NOMENCLATURA OBRIGAT√ìRIA**: Usar `.spec.ts` para arquivos de teste

**LOCALIZA√á√ÉO OBRIGAT√ìRIA**: Mesmo diret√≥rio do arquivo sendo testado

## Fluxo de Desenvolvimento Linear

```
IN√çCIO
  ‚Üì
üìã Consultar [Matriz de Prioridades](mdc:#0-matriz-de-prioridades)
  ‚Üì
üîç Executar [An√°lise do C√≥digo Backend](mdc:#1-an√°lise-do-c√≥digo-backend)
  ‚Üì
üõ†Ô∏è Aplicar [Padr√µes de Testing](mdc:#padr√µes-de-testing) + [Mocking Strategies](mdc:#estrat√©gias-de-mocking)
  ‚Üì
‚öñÔ∏è Conflito? ‚Üí [Resolu√ß√£o de Conflitos](mdc:#resolu√ß√£o-de-conflitos)
  ‚Üì
‚úÖ [Verifica√ß√£o e Valida√ß√£o](mdc:#comandos-de-verifica√ß√£o)
  ‚Üì
üéØ FINALIZADO
```

## Modo R√°pido (Para mudan√ßas simples)

**Use quando**: Pequenas corre√ß√µes, ajustes de utilit√°rios, ou mudan√ßas triviais

**Processo simplificado**:
1. ‚úÖ Verificar se √© realmente simples (sem l√≥gica complexa de API)
2. üõ†Ô∏è Implementar seguindo padr√µes b√°sicos
3. ‚úÖ Validar apenas itens "Cr√≠ticos" do checklist

**Pular para casos simples**: An√°lise detalhada, documenta√ß√£o extensa, valida√ß√£o completa

## Quando Aplicar

Esta rule deve ser aplicada quando:
- Solicitado para criar testes de rotas Fastify
- Necess√°rio testar services e l√≥gica de neg√≥cio
- Requerido implementar testes de middleware
- Preciso testar reposit√≥rios com Prisma
- Solicitado para testar tratamento de erros e valida√ß√µes
- Necess√°rio testar utilit√°rios e helpers

## √çndice de Navega√ß√£o R√°pida

- üö® [Matriz de Prioridades](mdc:#0-matriz-de-prioridades) - **Consulte PRIMEIRO**
- ‚öñÔ∏è [Resolu√ß√£o de Conflitos](mdc:#resolu√ß√£o-de-conflitos) - Para decis√µes dif√≠ceis
- üîç [An√°lise do C√≥digo Backend](mdc:#1-an√°lise-do-c√≥digo-backend) - In√≠cio do desenvolvimento
- üõ†Ô∏è [Padr√µes de Testing](mdc:#padr√µes-de-testing) - Durante implementa√ß√£o
- ‚úÖ [Checklist Final](mdc:#checklist-de-valida√ß√£o-para-llm) - Antes de finalizar

## 0. Matriz de Prioridades

### Cr√≠tico (Bloqueia desenvolvimento)
- Teste espec√≠fico executando e passando
- Mocks de Prisma funcionais
- Nomenclatura correta (.spec.ts)

### Importante (Impacta qualidade)
- AAA pattern (Arrange-Act-Assert)
- Cen√°rios de sucesso e erro cobertos
- Mocks de middleware e autentica√ß√£o
- Estrutura de describe/it organizada

### Opcional (Melhoria incremental)
- Edge cases testados
- Cobertura de c√≥digo alta
- Testes de integra√ß√£o
- Performance de execu√ß√£o

## Resolu√ß√£o de Conflitos

### Ordem de Preced√™ncia:
1. **Funcionalidade > Padr√µes**: Se um padr√£o impede a funcionalidade, priorize a funcionalidade
2. **Seguran√ßa > Performance**: Nunca comprometa seguran√ßa por performance
3. **Legibilidade > Otimiza√ß√£o**: C√≥digo leg√≠vel √© mais importante que micro-otimiza√ß√µes
4. **Conven√ß√µes do projeto > Prefer√™ncias pessoais**: Siga o que j√° existe no projeto

### Protocolo de Decis√£o:
1. **Identifique o conflito**: Qual diretriz est√° sendo violada?
2. **Consulte a preced√™ncia**: Use a ordem acima para decidir
3. **Documente a exce√ß√£o**: Explique por que divergiu
4. **Valide o m√≠nimo**: Garanta que itens "Cr√≠ticos" ainda s√£o atendidos

### Exemplos Pr√°ticos:
```typescript
// ‚ùå Conflito: Padr√£o vs Funcionalidade
// Padr√£o diz: mock todas as depend√™ncias
// Mas: teste de integra√ß√£o precisa de Prisma real

// ‚úÖ Resolu√ß√£o: Priorizar funcionalidade
// Coment√°rio: "Teste de integra√ß√£o - Prisma real necess√°rio para validar fluxo completo"
```

### Quando Divergir:
- **Documente**: Adicione coment√°rio explicando a exce√ß√£o
- **Valide cr√≠ticos**: Confirme que lint, tipos e mocks ainda funcionam
- **Priorize entrega**: Funcionalidade working > padr√£o perfeito

## 1. An√°lise do C√≥digo Backend

**ANTES DE INICIAR**: Consulte a [Matriz de Prioridades](mdc:#0-matriz-de-prioridades)

**EXECUTAR OBRIGATORIAMENTE:**

- **Funcionalidade**: Identificar rotas, services ou reposit√≥rios a serem testados
- **Depend√™ncias**: Mapear Prisma, middleware e depend√™ncias externas
- **Comportamentos**: Listar cen√°rios de sucesso, erro e edge cases
- **Autentica√ß√£o**: Analisar necessidades de mock de JWT/auth
- **Valida√ß√µes**: Identificar schemas Zod e valida√ß√µes de entrada

**A√á√ÉO**: Use `read_file` e `codebase_search` para analisar o c√≥digo fonte.

### Diretrizes de An√°lise
- Identifique funcionalidades principais a serem testadas
- Mapeie depend√™ncias que precisam de mock (Prisma, JWT, etc.)
- Liste cen√°rios de API (200, 400, 401, 404, 500)
- Prossiga com implementa√ß√£o quando tiver clareza dos requisitos

## 2. Estrutura√ß√£o dos Testes

**A√á√ïES OBRIGAT√ìRIAS:**

- **Arquivo de teste**: Criar na mesma pasta do arquivo fonte
- **Nomenclatura**: Usar `.spec.ts`
- **Organiza√ß√£o**: Estruturar com `describe` e `it`
- **Setup**: Configurar mocks de Prisma, JWT e depend√™ncias

## Padr√µes de Testing

### Testing Framework

#### Tecnologias Principais
- **Unit Tests**: Jest + ts-jest
- **Test Environment**: Node.js
- **Mocking**: Jest mocks
- **Database**: Prisma mocks
- **Authentication**: JWT mocks

#### Filosofia de Testing
- Escrever descri√ß√µes de testes em ingl√™s
- Manter testes independentes
- Testar cen√°rios de sucesso e erro
- Usar AAA pattern (Arrange-Act-Assert)

### Service Testing Patterns

```typescript
import { createOrganizationService } from "./create-organization.service";
import { createOrganizationRepository } from "@/repositories/organizations/create-organization";
import { createSlug } from "@/utils/slug/create-slug";

jest.mock("@/repositories/organizations/create-organization");
jest.mock("@/utils/slug/create-slug");

describe("createOrganizationService", () => {
  const mockOrganization = {
    id: "org-1",
    name: "Test Org",
    slug: "test-org",
    domain: null,
    shouldAttachUsersByDomain: false,
    ownerId: "user-1",
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("should create organization successfully", async () => {
    // Arrange
    const input = {
      userId: "user-1",
      name: "Test Org",
      domain: null,
      shouldAttachUsersByDomain: false,
    };

    (createSlug as jest.Mock).mockReturnValue("test-org");
    (createOrganizationRepository as jest.Mock).mockResolvedValue(mockOrganization);

    // Act
    const result = await createOrganizationService(input);

    // Assert
    expect(createSlug).toHaveBeenCalledWith("Test Org");
    expect(createOrganizationRepository).toHaveBeenCalledWith({
      userId: "user-1",
      name: "Test Org",
      domain: null,
      slug: "test-org",
      shouldAttachUsersByDomain: false,
    });
    expect(result).toEqual(mockOrganization);
  });
});
```

### Repository Testing Patterns

```typescript
import { prisma } from "@/infra/prisma/prisma-connection";
import { createOrganizationRepository } from "./create-organization.repository";

jest.mock("@/infra/prisma/prisma-connection");

describe("createOrganizationRepository", () => {
  const mockOrganization = {
    id: "org-1",
    name: "Acme Inc",
    domain: "acme.com",
    slug: "acme-inc",
    shouldAttachUsersByDomain: true,
    ownerId: "user-1",
    members: [],
    createdAt: new Date(),
    updatedAt: new Date(),
  };

  beforeEach(() => {
    jest.clearAllMocks();
  });

  it("should create an organization and return it", async () => {
    // Arrange
    (prisma.organization.create as jest.Mock).mockResolvedValue(mockOrganization);
    const input = {
      userId: "user-1",
      name: "Acme Inc",
      domain: "acme.com",
      slug: "acme-inc",
      shouldAttachUsersByDomain: true,
    };

    // Act
    const result = await createOrganizationRepository(input);

    // Assert
    expect(prisma.organization.create).toHaveBeenCalledWith({
      data: {
        name: input.name,
        domain: input.domain,
        slug: input.slug,
        shouldAttachUsersByDomain: input.shouldAttachUsersByDomain,
        ownerId: input.userId,
        members: {
          create: {
            userId: input.userId,
            role: "ADMIN",
          },
        },
      },
    });
    expect(result).toEqual(mockOrganization);
  });

  it("should throw if prisma throws", async () => {
    // Arrange
    jest.mocked(prisma.organization.create).mockRejectedValueOnce(new Error());

    // Act & Assert
    await expect(createOrganizationRepository({} as any)).rejects.toThrow(
      "Failed to create organization"
    );
  });
});
```

### Middleware Testing Patterns

```typescript
import { getCurrentUserId } from "@/services/users/get-current-user-id";
import { FastifyInstance } from "fastify";
import { authMiddleware } from "./auth";

jest.mock("@/services/users/get-current-user-id");

describe("authMiddleware", () => {
  let app: FastifyInstance;
  let preHandler: (request: any, reply: any) => Promise<void>;

  beforeEach(async () => {
    app = {
      addHook: jest.fn((hookName, fn) => {
        if (hookName === "preHandler") {
          preHandler = fn;
        }
      }),
    } as unknown as FastifyInstance;

    await authMiddleware(app);
  });

  it("should call getCurrentUserId service when request.getCurrentUserId is called", async () => {
    // Arrange
    const request: any = {};
    const reply: any = {};
    (getCurrentUserId as jest.Mock).mockResolvedValue("user-123");

    await preHandler(request, reply);

    // Act
    const userId = await request.getCurrentUserId();

    // Assert
    expect(getCurrentUserId).toHaveBeenCalledWith(request);
    expect(userId).toBe("user-123");
  });
});
```

### Authentication Service Testing Patterns

```typescript
import { UnauthorizedError } from "@/routes/_error/4xx/unauthorized-error";
import { FastifyRequest } from "fastify";
import { getCurrentUserId } from "./get-current-user-id.service";

describe("getCurrentUserId", () => {
  it("should return the current user id when jwtVerify resolves with sub", async () => {
    // Arrange
    const request = {
      jwtVerify: jest.fn().mockResolvedValue({ sub: "123" }),
    } as unknown as FastifyRequest;

    // Act
    const userId = await getCurrentUserId(request);

    // Assert
    expect(userId).toBe("123");
    expect(request.jwtVerify).toHaveBeenCalled();
  });

  it("should throw UnauthorizedError if jwtVerify rejects", async () => {
    // Arrange
    const request = {
      jwtVerify: jest.fn().mockRejectedValue(new Error("Invalid token")),
    } as unknown as FastifyRequest;

    // Act & Assert
    await expect(getCurrentUserId(request)).rejects.toThrow(UnauthorizedError);
    await expect(getCurrentUserId(request)).rejects.toThrow("Invalid token");
    expect(request.jwtVerify).toHaveBeenCalled();
  });

  it("should throw UnauthorizedError if jwtVerify does not return sub", async () => {
    // Arrange
    const request = {
      jwtVerify: jest.fn().mockResolvedValue({}),
    } as unknown as FastifyRequest;

    // Act & Assert
    await expect(getCurrentUserId(request)).rejects.toThrow(UnauthorizedError);
    await expect(getCurrentUserId(request)).rejects.toThrow("Invalid token");
    expect(request.jwtVerify).toHaveBeenCalled();
  });
});
```

### Error Handler Testing Patterns

```typescript
import { hasZodFastifySchemaValidationErrors } from "fastify-type-provider-zod";
import { ZodError } from "zod";
import { NotFoundError } from "./4xx/not-found-error";
import { UnauthorizedError } from "./4xx/unauthorized-error";
import { errorHandler } from "./error-handler";

jest.mock("fastify-type-provider-zod");

describe("errorHandler", () => {
  let mockRequest: any;
  let mockReply: any;

  beforeEach(() => {
    jest.clearAllMocks();

    mockRequest = {
      method: "POST",
      url: "/test-endpoint",
      log: {
        error: jest.fn(),
      },
    };

    mockReply = {
      status: jest.fn().mockReturnThis(),
      send: jest.fn().mockReturnThis(),
    };
  });

  it("should handle Zod schema validation errors", () => {
    // Arrange
    const error = {
      validation: [
        {
          instancePath: "/email",
          message: "Invalid email format",
        },
      ],
    };
    jest.mocked(hasZodFastifySchemaValidationErrors).mockReturnValue(true);

    // Act
    errorHandler(error as any, mockRequest, mockReply);

    // Assert
    expect(mockReply.status).toHaveBeenCalledWith(400);
    expect(mockReply.send).toHaveBeenCalledWith({
      message: "Validation failed",
      errors: {
        email: "Invalid email format",
      },
    });
  });

  it("should handle NotFoundError", () => {
    // Arrange
    const error = new NotFoundError("Resource not found");
    jest.mocked(hasZodFastifySchemaValidationErrors).mockReturnValue(false);

    // Act
    errorHandler(error as any, mockRequest, mockReply);

    // Assert
    expect(mockReply.status).toHaveBeenCalledWith(404);
    expect(mockReply.send).toHaveBeenCalledWith({
      message: "Resource not found",
    });
  });

  it("should handle generic errors with 500 status", () => {
    // Arrange
    const error = new Error("Something went wrong");
    jest.mocked(hasZodFastifySchemaValidationErrors).mockReturnValue(false);

    // Act
    errorHandler(error as any, mockRequest, mockReply);

    // Assert
    expect(mockRequest.log.error).toHaveBeenCalledWith(error);
    expect(mockReply.status).toHaveBeenCalledWith(500);
    expect(mockReply.send).toHaveBeenCalledWith({
      message: "Internal server error",
    });
  });
});
```

### Utility Testing Patterns

```typescript
import { createSlug } from "./create-slug";

describe("createSlug", () => {
  it("should convert text to lowercase slug", () => {
    // Arrange
    const input = "Hello World";

    // Act
    const result = createSlug(input);

    // Assert
    expect(result).toBe("hello-world");
  });

  it("should remove accents and special characters", () => {
    // Arrange
    const input = "Ol√° Mundo! @#$%";

    // Act
    const result = createSlug(input);

    // Assert
    expect(result).toBe("ola-mundo");
  });

  it("should handle multiple spaces and hyphens", () => {
    // Arrange
    const input = "  Hello    World  --  Test  ";

    // Act
    const result = createSlug(input);

    // Assert
    expect(result).toBe("hello-world-test");
  });
});
```

## Estrat√©gias de Mocking

### Prisma Mocking
- Use mock centralizado em `__mocks__/prisma-connection.ts`
- Mock m√©todos espec√≠ficos por teste
- Mantenha consist√™ncia entre testes

```typescript
// __mocks__/prisma-connection.ts
const mockDbMethods = {
  findFirst: jest.fn(),
  findUnique: jest.fn(),
  create: jest.fn(),
  update: jest.fn(),
  delete: jest.fn(),
  findMany: jest.fn(),
};

export const prisma = {
  organization: mockDbMethods,
  user: mockDbMethods,
  member: mockDbMethods,
  project: mockDbMethods,
};
```

### JWT/Authentication Mocking
- Mock `jwtVerify` para testes de autentica√ß√£o
- Simule cen√°rios de token v√°lido/inv√°lido
- Teste casos de erro de autentica√ß√£o

### Service Dependencies Mocking
- Mock depend√™ncias externas
- Use `jest.mock()` para m√≥dulos
- Mantenha mocks simples e focados

## Comandos de Verifica√ß√£o

**EXECUTAR OBRIGATORIAMENTE antes de finalizar:**

- **Execu√ß√£o de Testes**: Use `run_terminal_cmd` com `npm test [arquivo.spec.ts]` para executar apenas o teste espec√≠fico
- **Valida√ß√£o de Resultados**: Confirme que o teste espec√≠fico passa

**A√á√ïES OBRIGAT√ìRIAS:**
```bash
# 1. Executar apenas o teste espec√≠fico
npm test example.service.spec.ts

# 2. Verificar se o teste espec√≠fico passa
# 3. Se o teste falhar, corrigir antes de finalizar
```

**IMPORTANTE**: N√£o finalize a implementa√ß√£o de testes se houver:
- Teste espec√≠fico falhando
- Warnings cr√≠ticos n√£o resolvidos no arquivo

## Checklist de Valida√ß√£o para LLM

**OBRIGAT√ìRIO verificar antes de finalizar:**
**PRIORIZE**: Itens marcados como "Cr√≠tico" na [Matriz de Prioridades](mdc:#0-matriz-de-prioridades)

#### ‚úÖ Cr√≠tico (Bloqueia entrega)
- [ ] Teste espec√≠fico executando e passando
- [ ] Mocks de Prisma funcionais
- [ ] Nomenclatura correta (.spec.ts)

#### ‚úÖ Importante (Impacta qualidade)
- [ ] AAA pattern (Arrange-Act-Assert) seguido
- [ ] Cen√°rios de sucesso e erro cobertos
- [ ] Mocks de middleware e autentica√ß√£o implementados
- [ ] Estrutura de describe/it organizada

#### ‚úÖ Opcional (Melhoria incremental)
- [ ] Edge cases testados
- [ ] Cobertura de c√≥digo considerada
- [ ] Performance de execu√ß√£o otimizada

**IMPORTANTE**: N√£o finalize sem completar itens "Cr√≠ticos".

## Jest Configuration

### Configura√ß√£o Base
```typescript
// jest.config.ts
import type { Config } from "jest";

const config: Config = {
  preset: "ts-jest",
  testEnvironment: "node",
  roots: ["<rootDir>/src"],
  moduleFileExtensions: ["ts", "js", "json"],
  testMatch: ["**/*.spec.ts"],
  collectCoverageFrom: ["src/**/*.{ts,js}"],
  coverageDirectory: "coverage",
  transform: {
    "^.+\\.(ts|tsx)$": "ts-jest",
  },
  moduleNameMapper: {
    "^@/(.*)$": "<rootDir>/src/$1",
  },
};

export default config;
```

### Scripts de Teste
```json
{
  "scripts": {
    "test": "jest",
    "test:watch": "jest --watch",
    "test:coverage": "jest --coverage"
  }
}
```
