---
description: 
globs: 
alwaysApply: false
---
---
description: Frontend testing guidelines
globs: ["**.spec/*"]
alwaysApply: true
---

# Testing Guidelines

## Instru√ß√µes para LLM

**A√á√ÉO OBRIGAT√ìRIA**: Quando solicitado para criar ou revisar testes, siga EXATAMENTE esta sequ√™ncia:

1. **VERIFICAR**: Confirme se a solicita√ß√£o se enquadra nos crit√©rios da se√ß√£o "Quando Aplicar"
2. **ANALISAR**: Execute an√°lise do c√≥digo a ser testado usando ferramentas dispon√≠veis
3. **ESTRUTURAR**: Organize os testes seguindo os padr√µes estabelecidos
4. **IMPLEMENTAR**: Use os patterns e melhores pr√°ticas definidas
5. **VERIFICAR LINT**: Execute `npx eslint [arquivo]` para verificar erros de lint APENAS no arquivo espec√≠fico
6. **EXECUTAR TESTES**: Execute `npm test [arquivo.spec.ts]` para validar que o teste espec√≠fico passa
7. **VALIDAR**: Verifique se seguiu todas as diretrizes antes de finalizar

**ECONOMIA DE RECURSOS**: SEMPRE execute lint e testes apenas nos arquivos espec√≠ficos, n√£o no projeto todo

**NOMENCLATURA OBRIGAT√ìRIA**: Usar `.spec.ts` ou `.spec.tsx` para arquivos de teste

**LOCALIZA√á√ÉO OBRIGAT√ìRIA**: Mesmo diret√≥rio do arquivo sendo testado

## Fluxo de Desenvolvimento Linear

```
IN√çCIO
  ‚Üì
üìã Consultar [Matriz de Prioridades](mdc:#0-matriz-de-prioridades)
  ‚Üì
üîç Executar [An√°lise do C√≥digo](mdc:#1-an√°lise-do-c√≥digo)
  ‚Üì
üõ†Ô∏è Aplicar [Padr√µes de Testing](mdc:#padr√µes-de-testing) + [Mocking](mdc:#estrat√©gias-de-mocking)
  ‚Üì
‚öñÔ∏è Conflito? ‚Üí [Resolu√ß√£o de Conflitos](mdc:#resolu√ß√£o-de-conflitos)
  ‚Üì
‚úÖ [Verifica√ß√£o e Valida√ß√£o](mdc:#comandos-de-verifica√ß√£o)
  ‚Üì
üéØ FINALIZADO
```

## Modo R√°pido (Para mudan√ßas simples)

**Use quando**: Pequenas corre√ß√µes, ajustes de estilo, ou mudan√ßas triviais

**Processo simplificado**:
1. ‚úÖ Verificar se √© realmente simples (sem l√≥gica complexa)
2. üõ†Ô∏è Implementar seguindo padr√µes b√°sicos
3. üîç Executar `npx eslint [arquivo]`
4. ‚úÖ Validar apenas itens "Cr√≠ticos" do checklist

**Pular para casos simples**: An√°lise detalhada, documenta√ß√£o extensa, valida√ß√£o completa

## Quando Aplicar

Esta rule deve ser aplicada quando:
- Solicitado para criar testes unit√°rios ou de componentes
- Necess√°rio revisar ou melhorar testes existentes
- Requerido implementar mocks ou test builders
- Preciso seguir padr√µes de teste do projeto

## √çndice de Navega√ß√£o R√°pida

- üö® [Matriz de Prioridades](mdc:#0-matriz-de-prioridades) - **Consulte PRIMEIRO**
- ‚öñÔ∏è [Resolu√ß√£o de Conflitos](mdc:#resolu√ß√£o-de-conflitos) - Para decis√µes dif√≠ceis
- üîç [An√°lise do C√≥digo](mdc:#1-an√°lise-do-c√≥digo) - In√≠cio do desenvolvimento
- üõ†Ô∏è [Padr√µes de Testing](mdc:#padr√µes-de-testing) - Durante implementa√ß√£o
- ‚úÖ [Checklist Final](mdc:#checklist-de-valida√ß√£o-para-llm) - Antes de finalizar

## 0. Matriz de Prioridades

### Cr√≠tico (Bloqueia desenvolvimento)
- Lint sem erros no arquivo de teste
- Teste espec√≠fico executando e passando
- Imports e mocks funcionais
- Nomenclatura correta (.spec.ts/.spec.tsx)

### Importante (Impacta qualidade)
- AAA pattern (Arrange-Act-Assert)
- Cen√°rios de sucesso e erro cobertos
- Mocks apropriados implementados
- Estrutura de describe/it organizada

### Opcional (Melhoria incremental)
- Edge cases testados
- Cobertura de c√≥digo alta
- Documenta√ß√£o de testes
- Performance de execu√ß√£o

## Resolu√ß√£o de Conflitos

### Ordem de Preced√™ncia:
1. **Funcionalidade > Padr√µes**: Se um padr√£o impede a funcionalidade, priorize a funcionalidade
2. **Seguran√ßa > Performance**: Nunca comprometa seguran√ßa por performance
3. **Legibilidade > Otimiza√ß√£o**: C√≥digo leg√≠vel √© mais importante que micro-otimiza√ß√µes
4. **Conven√ß√µes do projeto > Prefer√™ncias pessoais**: Siga o que j√° existe no projeto

### Protocolo de Decis√£o:
1. **Identifique o conflito**: Qual diretriz est√° sendo violada?
2. **Consulte a preced√™ncia**: Use a ordem acima para decidir
3. **Documente a exce√ß√£o**: Explique por que divergiu
4. **Valide o m√≠nimo**: Garanta que itens "Cr√≠ticos" ainda s√£o atendidos

### Exemplos Pr√°ticos:
```typescript
// ‚ùå Conflito: Padr√£o vs Funcionalidade
// Padr√£o diz: use function declarations
// Mas: callback precisa ser arrow function para binding

// ‚úÖ Resolu√ß√£o: Priorizar funcionalidade
const handleCallback = useCallback((data) => {
  // Arrow function necess√°ria para contexto correto
}, []);
```

### Quando Divergir:
- **Documente**: Adicione coment√°rio explicando a exce√ß√£o
- **Valide cr√≠ticos**: Confirme que lint, tipos e imports ainda funcionam
- **Priorize entrega**: Funcionalidade working > padr√£o perfeito

## 1. An√°lise do C√≥digo

**ANTES DE INICIAR**: Consulte a [Matriz de Prioridades](mdc:#0-matriz-de-prioridades)

**EXECUTAR OBRIGATORIAMENTE:**

- **Funcionalidade**: Identificar o que precisa ser testado
- **Depend√™ncias**: Mapear imports e depend√™ncias externas
- **Comportamentos**: Listar cen√°rios de sucesso e erro
- **Interfaces**: Analisar props, par√¢metros e retornos

**A√á√ÉO**: Use `read_file` e `codebase_search` para analisar o c√≥digo fonte.

### Diretrizes de An√°lise
- Identifique funcionalidades principais a serem testadas
- Mapeie depend√™ncias que precisam de mock
- Liste cen√°rios de sucesso e erro b√°sicos
- Prossiga com implementa√ß√£o quando tiver clareza dos requisitos

## 2. Estrutura√ß√£o dos Testes

**A√á√ïES OBRIGAT√ìRIAS:**

- **Arquivo de teste**: Criar na mesma pasta do arquivo fonte
- **Nomenclatura**: Usar `.spec.ts` ou `.spec.tsx`
- **Organiza√ß√£o**: Estruturar com `describe` e `it`
- **Setup**: Configurar mocks e imports necess√°rios

## 3. Implementa√ß√£o

**DIRETRIZES OBRIGAT√ìRIAS:**

- **AAA Pattern**: Arrange-Act-Assert em todos os testes
- **Descri√ß√µes em ingl√™s**: Nomes de testes claros e descritivos
- **Mocking apropriado**: Mock apenas o necess√°rio
- **Cleanup**: Limpar mocks entre testes

## 4. Verifica√ß√£o e Valida√ß√£o

**EM CASO DE CONFLITO**: Consulte [Resolu√ß√£o de Conflitos](mdc:#resolu√ß√£o-de-conflitos)

**EXECUTAR OBRIGATORIAMENTE antes de finalizar:**

- **Verifica√ß√£o de Lint**: Use `run_terminal_cmd` com `npx eslint [arquivo]` para verificar erros de lint no arquivo espec√≠fico
- **Corre√ß√£o de Lint**: Se houver erros, corrija-os antes de prosseguir
- **Execu√ß√£o de Testes**: Use `run_terminal_cmd` com `npm test [arquivo.spec.ts]` para executar apenas o teste espec√≠fico
- **Valida√ß√£o de Resultados**: Confirme que o teste espec√≠fico passa

**A√á√ïES OBRIGAT√ìRIAS:**
```bash
# 1. Verificar lint apenas no arquivo espec√≠fico (economiza recursos)
npx eslint src/components/Button/Button.tsx

# 2. Se lint passou, executar apenas o teste espec√≠fico
npm test Button.spec.tsx

# 3. Verificar se o teste espec√≠fico passa
# 4. Se o teste falhar, corrigir antes de finalizar
```

**IMPORTANTE**: N√£o finalize a implementa√ß√£o de testes se houver:
- Erros de lint n√£o corrigidos no arquivo espec√≠fico
- Teste espec√≠fico falhando
- Warnings cr√≠ticos n√£o resolvidos no arquivo

## 5. Testing Framework

### Tecnologias Principais
- **Unit Tests**: Jest
- **Component Tests**: React Testing Library
- **Hook Tests**: @testing-library/react
- **E2E Tests**: (quando aplic√°vel)

### Filosofia de Testing
- Escrever descri√ß√µes de testes em ingl√™s
- Manter testes independentes
- Testar cen√°rios de sucesso e erro
- Focar em testar comportamento, n√£o implementa√ß√£o

## Configura√ß√£o e Setup de Testes

### Setup Inicial de Testes

```typescript
// Imports obrigat√≥rios
import { render, screen } from '@testing-library/react';
import { renderHook } from '@testing-library/react';
import { act } from 'react';

// Mock de depend√™ncias
jest.mock('../@shared/stateManagement/ComponentData');
jest.mock('../@shared/validations/fieldType');

// Setup e cleanup
beforeEach(() => {
  jest.clearAllMocks();
  jest.mocked(validateTextField).mockReturnValue([]);
});
```

### Estrutura de Arquivos e Nomenclatura

- Usar extens√£o `.spec.ts` ou `.spec.tsx`
- Colocar arquivos de teste na mesma pasta do arquivo fonte
- Seguir conven√ß√£o de nomenclatura:

```
‚î£ utils/
‚îÉ ‚î£ group-children.ts
‚îÉ ‚î£ group-children.spec.ts
‚î£ components/
‚îÉ ‚î£ Button/
‚îÉ ‚îÉ ‚î£ Button.tsx
‚îÉ ‚îÉ ‚î£ Button.spec.tsx
```

## Organiza√ß√£o de Testes

### Estrutura e Agrupamento
- Agrupar testes relacionados com blocos `describe`
- Sempre usar `it` (n√£o `test`)
- Seguir padr√£o AAA (Arrange-Act-Assert)
- Usar nomes descritivos que expliquem o comportamento esperado

```typescript
describe('useTextField', () => {
  describe('initialization', () => {
    it('should initialize with given value', () => {
      // Arrange
      const field = new FieldBuilder().build();
      const initialValue = 'Initial Value';

      // Act
      const { result } = renderHook(() =>
        useTextField({ field, value: initialValue }),
      );

      // Assert
      expect(result.current.textFieldValue).toBe(initialValue);
    });
  });

  describe('validation', () => {
    it('should validate field when value changes', () => {
      // Test implementation
    });
  });
});
```

## Padr√µes de Testing

### Testing de Componentes

```typescript
describe('Button Component', () => {
  it('should render with correct text', () => {
    // Arrange
    const buttonText = 'Click me';

    // Act
    render(<Button>{buttonText}</Button>);

    // Assert
    expect(screen.getByRole('button', { name: buttonText })).toBeInTheDocument();
  });

  it('should call onClick handler when clicked', () => {
    // Arrange
    const handleClick = jest.fn();

    // Act
    render(<Button onClick={handleClick}>Click me</Button>);
    fireEvent.click(screen.getByRole('button'));

    // Assert
    expect(handleClick).toHaveBeenCalledTimes(1);
  });
});
```

### Testing de Hooks

```typescript
describe('useCustomHook', () => {
  it('should return initial state', () => {
    // Arrange & Act
    const { result } = renderHook(() => useCustomHook());

    // Assert
    expect(result.current.value).toBe('');
    expect(result.current.isLoading).toBe(false);
  });

  it('should update state when action is called', () => {
    // Arrange
    const { result } = renderHook(() => useCustomHook());

    // Act
    act(() => {
      result.current.setValue('new value');
    });

    // Assert
    expect(result.current.value).toBe('new value');
  });
});
```

### Testing Ass√≠ncrono

```typescript
describe('async operations', () => {
  it('should handle async data loading', async () => {
    // Arrange
    const mockData = { id: 1, name: 'Test' };
    jest.mocked(fetchData).mockResolvedValue(mockData);

    // Act
    render(<AsyncComponent />);

    // Assert
    expect(screen.getByText('Loading...')).toBeInTheDocument();
    
    await waitFor(() => {
      expect(screen.getByText('Test')).toBeInTheDocument();
    });
  });
});
```

## Estrat√©gias de Mocking

### Mocking B√°sico

```typescript
// ‚úÖ Correto:
jest.mocked(useComponentData).mockReturnValue({
  handleUpdateField: jest.fn(),
} as unknown as UseComponentDataProps);
```

### Mocking de M√≥dulos

```typescript
// Mock de m√≥dulos inteiros
jest.mock('../@shared/stateManagement/ComponentData');
jest.mock('../@shared/validations/fieldType');

// Mock de fun√ß√µes espec√≠ficas
jest.mock('../utils/api', () => ({
  fetchData: jest.fn(),
  postData: jest.fn(),
}));
```

### Diretrizes Globais de Mocking
- Fazer mock de objetos globais quando necess√°rio
- N√£o fazer mock do que j√° est√° mockado em `./tests/unit/setupTests/`
- Limpar mocks entre testes usando `jest.clearAllMocks()`

## Padr√£o Builder para Testes

### Test Data Builders

```typescript
class FieldBuilder {
  private field: Field = {
    id: 'test-field',
    type: 'text',
    allowNumbers: true,
    allowLetters: true,
    allowSpecialChars: false,
  };

  withAllowNumbers(allow: boolean): FieldBuilder {
    this.field.allowNumbers = allow;
    return this;
  }

  withAllowLetters(allow: boolean): FieldBuilder {
    this.field.allowLetters = allow;
    return this;
  }

  withAllowSpecialChars(allow: boolean): FieldBuilder {
    this.field.allowSpecialChars = allow;
    return this;
  }

  build(): Field {
    return { ...this.field };
  }
}

// Usage in tests
const field = new FieldBuilder()
  .withAllowNumbers(true)
  .withAllowLetters(false)
  .withAllowSpecialChars(false)
  .build();
```

## Melhores Pr√°ticas de Testing

### Qualidade dos Testes
- Escrever nomes de testes claros e descritivos
- Testar uma coisa por vez
- Usar assertions significativas
- Evitar testar detalhes de implementa√ß√£o
- Testar casos extremos e cen√°rios de erro

### Performance
- Manter testes r√°pidos e focados
- Evitar opera√ß√µes DOM desnecess√°rias
- Usar m√©todos de cleanup apropriados
- Fazer mock de depend√™ncias pesadas

### Manutenibilidade
- Manter testes simples e leg√≠veis
- Usar fun√ß√µes auxiliares para setup comum
- Evitar c√≥digo duplicado nos testes
- Atualizar testes quando requisitos mudarem

### Diretrizes de Cobertura
- Buscar alta cobertura de testes mas focar em qualidade sobre quantidade
- Priorizar testes de l√≥gica de neg√≥cio cr√≠tica
- Testar intera√ß√µes do usu√°rio e workflows
- Incluir cen√°rios de tratamento de erros

## Cen√°rios Comuns de Testing

### Testing de Formul√°rios

```typescript
describe('ContactForm', () => {
  it('should submit form with valid data', async () => {
    // Arrange
    const mockSubmit = jest.fn();
    render(<ContactForm onSubmit={mockSubmit} />);

    // Act
    fireEvent.change(screen.getByLabelText('Name'), {
      target: { value: 'John Doe' }
    });
    fireEvent.change(screen.getByLabelText('Email'), {
      target: { value: 'john@example.com' }
    });
    fireEvent.click(screen.getByRole('button', { name: 'Submit' }));

    // Assert
    await waitFor(() => {
      expect(mockSubmit).toHaveBeenCalledWith({
        name: 'John Doe',
        email: 'john@example.com'
      });
    });
  });
});
```

### Testing de Integra√ß√£o com API

```typescript
describe('API integration', () => {
  it('should handle API errors gracefully', async () => {
    // Arrange
    const errorMessage = 'Network error';
    jest.mocked(fetchData).mockRejectedValue(new Error(errorMessage));

    // Act
    render(<DataComponent />);

    // Assert
    await waitFor(() => {
      expect(screen.getByText(`Error: ${errorMessage}`)).toBeInTheDocument();
    });
  });
});
```

### Testing de Gerenciamento de Estado

```typescript
describe('state management', () => {
  it('should update global state correctly', () => {
    // Arrange
    const { result } = renderHook(() => useGlobalState());

    // Act
    act(() => {
      result.current.updateUser({ id: 1, name: 'John' });
    });

    // Assert
    expect(result.current.user).toEqual({ id: 1, name: 'John' });
  });
});
```

## Debug de Testes

### Problemas Comuns
- Opera√ß√µes ass√≠ncronas n√£o aguardadas adequadamente
- Falta de cleanup entre testes
- Setup de mocking incorreto
- Testar implementa√ß√£o ao inv√©s de comportamento

### Ferramentas de Debug
- Usar `screen.debug()` para ver o estado atual do DOM
- Adicionar `console.log` para debug de valores
- Usar `waitFor` para opera√ß√µes ass√≠ncronas
- Verificar hist√≥rico de chamadas de mock com `toHaveBeenCalledWith`

### Isolamento de Testes
- Garantir que testes n√£o dependam uns dos outros
- Limpar efeitos colaterais em `afterEach`
- Resetar mocks entre testes
- Evitar estado mut√°vel compartilhado

## Comandos de Verifica√ß√£o

### Sequ√™ncia Obrigat√≥ria de Comandos

**SEMPRE execute nesta ordem para economizar recursos:**

```bash
# 1. PRIMEIRO: Verificar lint apenas no arquivo espec√≠fico (r√°pido, detecta erros de sintaxe)
npx eslint src/components/Button/Button.tsx

# 2. SEGUNDO: Se lint passou, executar apenas o teste espec√≠fico
npm test Button.spec.tsx

# Comandos alternativos para testes espec√≠ficos:
npm test -- --testNamePattern="Button"     # Testes que contenham "Button" no nome
npm test Button.spec.tsx --watch           # Modo watch para o arquivo espec√≠fico
npm test Button.spec.tsx --coverage        # Com relat√≥rio de cobertura do arquivo
```

### Tratamento de Erros

**Se lint falhar:**
- Corrigir TODOS os erros de lint no arquivo espec√≠fico antes de prosseguir
- N√£o executar testes at√© lint do arquivo estar limpo
- Usar `npx eslint [arquivo] --fix` para corre√ß√µes autom√°ticas

**Se testes falharem:**
- Analisar mensagens de erro detalhadamente
- Corrigir implementa√ß√£o ou testes conforme necess√°rio
- Re-executar apenas o teste espec√≠fico at√© passar
- Verificar se n√£o h√° testes flaky (inst√°veis)

### Comandos para LLM

**USAR SEMPRE `run_terminal_cmd` com estes comandos:**
- `npx eslint [caminho/do/arquivo]` - Verifica√ß√£o de lint no arquivo espec√≠fico
- `npm test [arquivo.spec.ts]` - Execu√ß√£o do teste espec√≠fico
- `npx eslint [arquivo] --fix` - Corre√ß√£o autom√°tica de lint no arquivo
- `npm test [arquivo.spec.ts] --watch` - Modo watch para desenvolvimento

### Exemplos Pr√°ticos

```bash
# Para um componente Button:
npx eslint src/components/Button/Button.tsx
npm test Button.spec.tsx

# Para um hook customizado:
npx eslint src/hooks/useCustomHook.ts
npm test useCustomHook.spec.ts

# Para um utilit√°rio:
npx eslint src/utils/formatDate.ts
npm test formatDate.spec.ts
```

## Checklist de Valida√ß√£o para LLM

Antes de finalizar os testes, OBRIGATORIAMENTE verificar:
**PRIORIZE**: Itens marcados como "Cr√≠tico" na [Matriz de Prioridades](mdc:#0-matriz-de-prioridades)

### ‚úÖ Cr√≠tico (Bloqueia entrega)
- [ ] Lint executado sem erros no arquivo espec√≠fico
- [ ] Teste espec√≠fico executado com `npm test [arquivo.spec.ts]`
- [ ] Teste espec√≠fico passando sem falhas
- [ ] Nomenclatura correta: `.spec.ts` ou `.spec.tsx`

### ‚úÖ Importante (Impacta qualidade)
- [ ] AAA pattern seguido (Arrange-Act-Assert)
- [ ] Mocks apropriados implementados
- [ ] Cen√°rios de sucesso e erro testados
- [ ] Edge cases cobertos

**IMPORTANTE**: N√£o finalize sem completar itens "Cr√≠ticos".
